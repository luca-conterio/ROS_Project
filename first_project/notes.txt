#####################
#   GROUP MEMBERS   #
#####################

-----------------------
     Luca Conterio
-----------------------
Codice Persona: 10498418 
Matricola: 920261

-----------------------
   Giulio Cristofaro
-----------------------
Codice Persona: 10555172
Matricola: 876730

-----------------------
    Andrea Ferraris
-----------------------
Codice Persona: 10580132
Matricola: 867817


#########################
#   PROJECT STRUCTURE   #
#########################

first_project
   ├── cfg
   │   └── parameters.cfg
   ├── CMakeLists.txt
   ├── launch
   │   └── first_project.launch
   ├── msg
   │   ├── floatStamped.msg
   │   └── odometryMessage.msg
   ├── package.xml
   └── src
       └── node.cpp


#############
#   NODES   #
#############
We produced a single node that subscribes to the needed topics (/speedR_stamped, /speedL_stamped, /steer_stamped)
and also publishes odometry data after computation. Odometry data is published with a standard nav_msgs::Odometry message 
(useful to be plotted for visualization), a custom first_project::odometryMessage, that contains odometry data along with 
the odometry type ("Differential_Drive" or "Ackerman"), and as tf transform.


##############
#   LAUNCH   # 
##############
A simple launch file is provided to start the ros node. 
Simply use roslaunch to run it.


###########################
#   MESSAGES AND TOPICS   #
###########################
In the msg folder two custom message definitions are contained:
  * floatStamped.msg: used to subscribe to car sensors data, since bag files data are formatted as this type of message ("/speedR_stamped", "/speedL_stamped" and "/steer_stamped" topics). Since these message contain their timestamp, the node uses an approximate time policy to synchronize the messages.
  * odometryMessage.msg: used by the node to publish odometry data along with the odometry type used in the computation (that can be either "Differential_Drive" or "Ackerman"). So it contains a nav_msgs::Odometry field called "odometry" and a string field called "source_type".  
  
Besides these two custom message types, the node uses nav_msgs::Odometry to publish odometry data in a standard way, so that it is simpler to plot those data for trajectory visualization.
  
As a result odometry data messages are published onto two topics:
  * nav_msgs::Odometry messages are published onto "/car_odometry" topic.
  * first_project::odometryMessage messages are published onto "/car_odometry_with_type" topic (custom message type).

                           _________________                                   _______________
                          /                 \                                 /               \
                  -----> |  /speedR_stamped  | -----                  -----> |  /car_odometry  |
                 /        \_________________/       \                /        \_______________/
    __________  /          _________________         \   __________ /
   /          \           /                 \         > /          \
  |  /rosbag   | ------> |  /speedL_stamped  | ------> |   /node    |
   \__________/           \_________________/         > \__________/
               \           _________________         /              \           _________________________
                \         /                 \       /                \         /                         \
                  -----> |      /steer       | -----                   -----> |  /car_odometry_with_type  |
                          \_________________/                                  \_________________________/


#########################
#   TF TREE STRUCTURE   #
#########################
Odometry data is published also as a tf transform through a tf::TransformBroadcaster.
This is the tf tree structure, where "odom" is the parent frame, while "car_frame" is the robot's frame:
    __________
   /          \
  |    odom    |
   \__________/
        |
        |
        |
        V
    __________
   /          \
  | car_frame  |
   \__________/


############################
#   ODOMETRY COMPUTATION   #
############################
To have a better approximation of the real values, the odometry is computed according to the Rugge-Kutta integration, instead of the Euler's one:

x_k+1 = x_k + v * dt * cos(theta_k + (w_k * dt) / 2)
y_k+1 = y_k + v * dt * sin(theta_k + (w_k * dt) / 2)
theta_k+1 = theta_k + (w_k * dt)
dt = T_k+1 - T_k

where k indicates the current iteration and k+1 the following one, dt the elapsed time between the two consecutive iterations and w the angular velocity.
The angular velocity is instead computed according to the selected odometry type (differential drive or Ackerman).


###################################
#   CONFIGURATION AND PARAMETERS  #
###################################
The cfg directory contains a parameters.cfg file with the specification of a ParameterGenerator.  
It is used in the node to instantiate a dynamice_reconfigure::Server to allow dynamic reconfiguration of the robot 
position (x,y).  
Three parameters have been defined:
  * x_pos: it respresents the robot's x coordinate.
  * y_pos: it represents the robot's y coordinate.
  * reset_position: it is used to enable the user to set the robot's position to a desired value (x,y).
  * odometry_type: it is used to change the type of odometry (0 for Differential_Drive and 1 for Ackerman).


###########################
#   DYNAMIC RECONFIGURE   #
###########################
It is used to set/reset the robot position to an arbitrary position (x,y). 
The parameters to be modified to set the position are: x_pos and y_pos. After you have set the position to the requested one, if you set the reset_position parameter to "true" the dynamic_reconfigure::Server callback function is called, setting the robot position to the specified one.  
  
We decided not to reset the orientation to a specified value nor to 0 when a dynamic reconfiguration of robot position 
is performed, so the node continues computing the odometry based on the previously computed orientation, also after a reset of its position (x,y).
  
NOTE: the reconfiguration is performed only if reset_position parameter is set to "true". This parameter acts as a sort of "button" (in rqt_reconfigure it appears as a checkbox) that modifies the current robot position. It is useful to set x_pos and y_pos to the desired ones, then set reset_position to "true" to update the robot position and put reset_position to "false" again before setting the position to a new value, repeating the procedure. This allows you to update the position "in one shot".
  
For what concerns changing the odometry computation type, it can be done simple changing the odometry_type paramter value (dropdown menu in rqt_reconfigure), selecting the desired odometry type.

NOTE: of course, if you change the odometry_type parameter while reset_position is set to "true", the callback function for the ParameterServer will be called and also the position will be updated to the value of x_pos and y_pos. It is more useful to change the odometry_type when reset_position is set to "false", so that only the odometry type will be changed.

